name: Deploy Convertix API (Production)

on:
  push:
    branches: [ main ]

permissions:
  id-token: write
  contents: read

concurrency:
  group: convertix-prod
  cancel-in-progress: true

env:
  DOTNET_VERSION: "8.0.x"
  API_PROJECT: services/api/PdfEditor.Api.csproj
  PUBLISH_DIR: services/api/out
  ZIP_PATH: api.zip
  IMAGE_NAME: convertix-api

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      # -----------------------------
      # 1. Checkout
      # -----------------------------
      - name: Checkout repository
        uses: actions/checkout@v4

      # -----------------------------
      # 2. Azure Login
      # -----------------------------
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # -----------------------------
      # 3. Install sqlcmd
      # -----------------------------
      - name: Install sqlcmd (Microsoft repo)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y curl apt-transport-https gnupg
          curl -sSL https://packages.microsoft.com/keys/microsoft.asc | sudo gpg --batch --yes --dearmor -o /usr/share/keyrings/microsoft-prod.gpg
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft-prod.gpg] https://packages.microsoft.com/ubuntu/24.04/prod noble main" | sudo tee /etc/apt/sources.list.d/microsoft-prod.list
          sudo apt-get update -y
          sudo ACCEPT_EULA=Y apt-get install -y msodbcsql18 mssql-tools18 unixodbc-dev
          echo "/opt/mssql-tools18/bin" >> $GITHUB_PATH

      # -----------------------------
      # 4. Run DB migrations
      # -----------------------------
      - name: Apply Azure SQL schema
        env:
          AZURE_SQL_CONNECTION: ${{ secrets.AZURE_SQL_CONNECTION }}
        run: |
          python3 - <<'PY'
          import os
          import re
          conn = os.environ["AZURE_SQL_CONNECTION"]
          parts = {}
          for chunk in conn.split(';'):
            if not chunk.strip():
              continue
            key, _, value = chunk.partition('=')
            parts[key.strip().lower()] = value.strip()
          server = parts.get('server') or parts.get('data source')
          if server and server.startswith('tcp:'):
            server = server[4:]
          database = parts.get('database') or parts.get('initial catalog')
          user = parts.get('user id') or parts.get('uid') or parts.get('user')
          password = parts.get('password') or parts.get('pwd')
          if not all([server, database, user, password]):
            raise SystemExit("Missing required fields in AZURE_SQL_CONNECTION")
          # sqlcmd wants server without tcp: prefix and with port if provided.
          print(server)
          print(database)
          print(user)
          print(password)
          PY
          SERVER=$(python3 - <<'PY'
          import os
          parts = {}
          for chunk in os.environ["AZURE_SQL_CONNECTION"].split(';'):
            if not chunk.strip():
              continue
            key, _, value = chunk.partition('=')
            parts[key.strip().lower()] = value.strip()
          server = parts.get('server') or parts.get('data source')
          if server and server.startswith('tcp:'):
            server = server[4:]
          print(server)
          PY
          )
          DATABASE=$(python3 - <<'PY'
          import os
          parts = {}
          for chunk in os.environ["AZURE_SQL_CONNECTION"].split(';'):
            if not chunk.strip():
              continue
            key, _, value = chunk.partition('=')
            parts[key.strip().lower()] = value.strip()
          print(parts.get('database') or parts.get('initial catalog'))
          PY
          )
          USER=$(python3 - <<'PY'
          import os
          parts = {}
          for chunk in os.environ["AZURE_SQL_CONNECTION"].split(';'):
            if not chunk.strip():
              continue
            key, _, value = chunk.partition('=')
            parts[key.strip().lower()] = value.strip()
          print(parts.get('user id') or parts.get('uid') or parts.get('user'))
          PY
          )
          PASSWORD=$(python3 - <<'PY'
          import os
          parts = {}
          for chunk in os.environ["AZURE_SQL_CONNECTION"].split(';'):
            if not chunk.strip():
              continue
            key, _, value = chunk.partition('=')
            parts[key.strip().lower()] = value.strip()
          print(parts.get('password') or parts.get('pwd'))
          PY
          )
          sqlcmd -S "$SERVER" -d "$DATABASE" -U "$USER" -P "$PASSWORD" -i services/api/SQL/schema.azure.sql

      # -----------------------------
      # 5. Schema diff
      # -----------------------------
      - name: Schema diff (Azure SQL)
        env:
          AZURE_SQL_CONNECTION: ${{ secrets.AZURE_SQL_CONNECTION }}
        run: |
          python3 - <<'PY'
          import json
          import os
          import subprocess
          import tempfile
          from pathlib import Path

          conn = os.environ["AZURE_SQL_CONNECTION"]
          parts = {}
          for chunk in conn.split(';'):
            if not chunk.strip():
              continue
            key, _, value = chunk.partition('=')
            parts[key.strip().lower()] = value.strip()
          server = parts.get('server') or parts.get('data source')
          if server and server.startswith('tcp:'):
            server = server[4:]
          database = parts.get('database') or parts.get('initial catalog')
          user = parts.get('user id') or parts.get('uid') or parts.get('user')
          password = parts.get('password') or parts.get('pwd')
          if not all([server, database, user, password]):
            raise SystemExit("Missing required fields in AZURE_SQL_CONNECTION")

          expected = json.loads(Path("services/api/SQL/schema.expect.json").read_text())
          table_names = list(expected["tables"].keys())
          quoted = ",".join([f"'{t}'" for t in table_names])
          query = f\"\"\"\n+          SET NOCOUNT ON;\n+          SELECT t.name AS table_name, c.name AS column_name\n+          FROM sys.tables t\n+          JOIN sys.columns c ON c.object_id = t.object_id\n+          WHERE t.name IN ({quoted})\n+          ORDER BY t.name, c.column_id;\n+          \"\"\"\n+
          cmd = [\"sqlcmd\", \"-S\", server, \"-d\", database, \"-U\", user, \"-P\", password, \"-W\", \"-s\", \"|\", \"-Q\", query]\n+          output = subprocess.check_output(cmd, text=True)\n+          lines = [line.strip() for line in output.splitlines() if line.strip() and \"table_name\" not in line]\n+          actual = {}\n+          for line in lines:\n+            if line.startswith(\"-\"):\n+              continue\n+            parts = [p.strip() for p in line.split(\"|\")]\n+            if len(parts) != 2:\n+              continue\n+            table, column = parts\n+            actual.setdefault(table, set()).add(column)\n+\n+          missing_tables = []\n+          missing_columns = {}\n+          for table, cols in expected[\"tables\"].items():\n+            if table not in actual:\n+              missing_tables.append(table)\n+              continue\n+            missing = [c for c in cols if c not in actual[table]]\n+            if missing:\n+              missing_columns[table] = missing\n+\n+          if missing_tables or missing_columns:\n+            print(\"Schema diff detected\")\n+            if missing_tables:\n+              print(\"Missing tables:\", \", \".join(missing_tables))\n+            if missing_columns:\n+              for table, cols in missing_columns.items():\n+                print(f\"Missing columns {table}: {', '.join(cols)}\")\n+            raise SystemExit(1)\n+          print(\"Schema diff: OK\")\n+          PY

      # -----------------------------
      # 6. Login to ACR
      # -----------------------------
      - name: Docker login to ACR
        run: |
          echo "${{ secrets.ACR_PASSWORD }}" | docker login "${{ secrets.ACR_LOGIN_SERVER }}" -u "${{ secrets.ACR_USERNAME }}" --password-stdin

      # -----------------------------
      # 7. Build + Push Image
      # -----------------------------
      - name: Build and push Docker image
        run: |
          IMAGE_TAG=${{ github.sha }}
          IMAGE_REF="${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"
          docker build -f services/api/Dockerfile -t "$IMAGE_REF" .
          docker push "$IMAGE_REF"
          echo "IMAGE_REF=$IMAGE_REF" >> $GITHUB_ENV

      # -----------------------------
      # 8. Deploy Image to App Service
      # -----------------------------
      - name: Deploy to Azure App Service (Container)
        uses: azure/webapps-deploy@v3
        with:
          app-name: ${{ secrets.AZURE_APP_NAME }}
          images: ${{ env.IMAGE_REF }}

      # -----------------------------
      # 9. Wait for App to be Ready
      # -----------------------------
      - name: Wait for app startup
        run: |
          echo "⏳ Waiting for app to become healthy..."
          for i in {1..12}; do
            if curl -fs "${{ secrets.API_BASE_URL }}/health" >/dev/null; then
              echo "✅ App is up"
              exit 0
            fi
            echo "…still starting ($i)"
            sleep 10
          done
          echo "❌ App did not become healthy in time"
          exit 1

      # -----------------------------
      # 10. Validate schema
      # -----------------------------
      - name: Validate schema (PROD)
        run: |
          curl -fs "${{ secrets.API_BASE_URL }}/health/schema" >/dev/null

      # -----------------------------
      # 11. Smoke Test (Image Engine)
      # -----------------------------
      - name: Smoke test image engine
        run: |
          curl -fs "${{ secrets.IMAGE_ENGINE_BASE_URL }}/health/tools" >/dev/null

      # -----------------------------
      # 12. Smoke Test (PROD)
      # -----------------------------
      - name: Run smoke tests
        run: |
          chmod +x scripts/smoke.sh
          API_BASE=${{ secrets.API_BASE_URL }} ./scripts/smoke.sh
